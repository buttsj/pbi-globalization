<!--[if IE ]><![endif]-->
<!DOCTYPE html>
<!-- <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"> -->
<!--[if lt IE 7 ]> <html class="no-js ie6 oldie lang_de" lang="de"> <![endif]-->
<!--[if IE 7 ]>    <html class="no-js ie7 oldie lang_de" lang="de"> <![endif]-->
<!--[if IE 8 ]>    <html class="no-js ie8 oldie lang_de" lang="de"> <![endif]-->
<!--[if (gte IE 9)|!(IE)]><!--><html class="no-js compliant lang_de" lang="de"> <!--<![endif]-->
	<head>

<!-- 

                   . .                  
                 .$7778...+=..      .   
   .          .,III77777777777..   .    
     ..    ..7II++I777777777777$..      
       ,   .IIII7II777777877777I7:.     
           .IIIIIII777777777777777.     
       .DIIIIIIIIII77777777777777D.     
    ...I?IIII?IIIII77777777777777$$D..  
 ...IIIIIIIIIIII7ID77777777777777$$$Z.  
 .IIIIII?IIIIIIIIII7777I777777777$$$$D  
 ?IIZDDI8$$IIIIIIII777?7777777777$$$$$. 
 .IIIII$$I7$$8I$8II$$O7IIZ7777777$$D$8  
 ZI?III?$+DOD8O8ZO7ZZZZ7Z?7I777$787$8.  
 .?IIIIII?OZZD88$$$$$$7I77777??$8$7:    
 ...IIIIIIIII .$D$$$DO77777777777$?.    
    ~II???II.   .$$$Z$$Z7O77DD77.       
      .:Z+.    .$$$$ZD......877Z        
           .   .D8$$ZD      .           
                .8O$$D                  
       .       .D$$$ZD         .        
               .$$$$$$.                 
              D$$$$$$$O$.               
   .        .$$?...$$8$..$Z~          

                                                                  __ /\_ \     
  ___ ___      __     _ __    __      ___          __    ___ ___ /\_\\//\ \    
/' __` __`\  /'__`\  /\`'__\/'__`\  /' _ `\      /'__`\/' __` __`\/\ \ \ \ \   
/\ \/\ \/\ \/\ \L\.\_\ \ \//\ \L\.\_/\ \/\ \    /\  __//\ \/\ \/\ \ \ \ \_\ \_ 
\ \_\ \_\ \_\ \__/.\_\\ \_\\ \__/.\_\ \_\ \_\   \ \____\ \_\ \_\ \_\ \_\/\____\
 \/_/\/_/\/_/\/__/\/_/ \/_/ \/__/\/_/\/_/\/_/    \/____/\/_/\/_/\/_/\/_/\/____/
                                                                               

 _     _             _ ____                              _                      _       
| |__ | |_ _ __ ___ | | ___|    _____  ___ __   ___ _ __(_)_ __ ___   ___ _ __ | |_ ___ 
| '_ \| __| '_ ` _ \| |___ \   / _ \ \/ / '_ \ / _ \ '__| | '_ ` _ \ / _ \ '_ \| __/ __|
| | | | |_| | | | | | |___) | |  __/>  <| |_) |  __/ |  | | | | | | |  __/ | | | |_\__ \
|_| |_|\__|_| |_| |_|_|____/   \___/_/\_\ .__/ \___|_|  |_|_| |_| |_|\___|_| |_|\__|___/
                                        |_|                                             
                                                                               
...........................................................

Ascii Generator - http://www.network-science.de/ascii/

Font: larry3d  
Font: ogre
Font: rectangles 
Font: rounded 
Font: shadow 
Font: slant
Font: small  
Font: smslant
Font: standard 
Font: stop

...........................................................

GlassGiant.com 
http://www.glassgiant.com/ascii/

...........................................................

-->
		<title>webGL GeoData using Three.js - example by Emil Maran</title>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">



		<style>
			body { background: #071E30; margin: 0px; overflow: hidden; }
			#info { position: absolute; top: 0px; width: 100%; color: #ffffff; padding: 5px; font-family: Monospace; font-size: 13px; text-align: center; }
			a { color: #ff0080; text-decoration: none; }
			a:hover { color: #0080ff; }
		</style>
	</head>
<body>

<div id="message"></div>

<style>
		#myCanvas { border: 1px solid #ff0000; }
		body { font-family: Monospace; background-color: #f0f0f0; margin: 0px; overflow: hidden; }
			*{ margin: 0px; padding: 0px }

</style>

<div id="message"></div>

<!-- <script src="http://maran-emil.de/experiments/demo12/js/three51.js"></script>
<script src="http://maran-emil.de/experiments/demo12/js/Stats.js"></script>
<script src="http://stemkoski.github.com/Three.js/js/THREEx.KeyboardState.js"></script>
<script src="http://stemkoski.github.com/Three.js/js/THREEx.FullScreen.js"></script>
<script src="http://stemkoski.github.com/Three.js/js/THREEx.WindowResize.js"></script> -->

<!-- <script src="js/Three.js"></script> -->
<script src="js/three51.js"></script>
<script src="js/Detector.js"></script>
<script src="js/Stats.js"></script>

<script src="js/THREEx_003.js"></script>
<script src="js/THREEx.js"></script>
<script src="js/THREEx_002.js"></script>

	<script type="text/javascript" src="js/THREE.FontText.js"></script>
       <!-- 
       
         <script type="text/javascript" src="helvetiker-normal-normal.js"></script>
        -->
       <!-- <script type="text/javascript" src="http://canvas-text.googlecode.com/svn-history/r41/trunk/faces/helvetiker-normal-normal.js"></script> -->
	<script type="text/javascript" src="js/helvetiker-normal-normal.js"></script>

	<script>

		/*
		https://github.com/mrdoob/three.js/blob/master/examples/webgl_interactive_draggablecubes.html
		http://jsfiddle.net/bmd0031/MhB2u/3/
		*/

		//http://stemkoski.github.com/Three.js/Mouse-Tooltip.html
		// http://stemkoski.github.com/Three.js/

		var SCREEN_WIDTH = window.innerWidth;
		var SCREEN_HEIGHT = window.innerHeight;
		
		var container, scene, camera, renderer, controls, stats;
		var keyboard = new THREEx.KeyboardState();
		var clock = new THREE.Clock();

		var text, plane;
		
		var sphereSize;
		var projector, mouse = { x: 0, y: 0 }, INTERSECTED,SELECTED;

		var mouse = new THREE.Vector2(),
            offset = new THREE.Vector3(),
            INTERSECTED, SELECTED;

		var sprite1;
		// standard global variables
		var container, scene, camera, renderer, controls, stats;
		var keyboard = new THREEx.KeyboardState();
		var clock = new THREE.Clock();

		// custom global variables
		var cube;
		var projector, mouse = { x: 0, y: 0 }, INTERSECTED;
		var sprite1;
		var canvas1, context1, texture1;

		var cube,cubex,particleMaterial,projector,gpspoint;

		var targetRotation = 0;
		var targetRotationOnMouseDown = 0;

		var mouseX = 0;
		var mouseY = 0;
		var mouseXOnMouseDown = 0;

		var windowHalfX = window.innerWidth / 2;
		var windowHalfY = window.innerHeight / 2;

		var arGeo = 
		{
		  "0": {"lat": "51.5",  "lon": "-0.117", "wikipedia":"London","city":"London"},
		  "1": {"lat": "-37.8", "lon": "144.95", "wikipedia":"Melbourne","city":"Melbourne"},
		  "2": {"lat": "37.767","lon": "-122.417", "wikipedia":"San_Francisco","city":"San Francisco"},
		  "3": {"lat": "35.683","lon": "139.767", "wikipedia":"Tokyo","city":"Tokyo"}
		};

		var objects = [];

		init();
		animate();
		
		setInterval(loop, 3000/60);

		function init() {
			
				scene = new THREE.Scene();

				// CAMERA
				var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;
				var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
				camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);

				//camera = new THREE.PerspectiveCamera( 65, SCREEN_WIDTH / SCREEN_HEIGHT, 1, 10000 );
				scene.add(camera);
				//camera.position.y = 150;
				camera.position.z = 700;
				//camera.position.x = 150;
				camera.lookAt(scene.position);

				// PLANE
				/*plane = new THREE.Mesh( 
					new THREE.PlaneGeometry( 200, 200, 8, 8 ), 
					new THREE.MeshBasicMaterial( { color: 0x000000, opacity: 0.25, transparent: true, wireframe: false } ) 
				);*/

				/*plane = new THREE.Mesh(
					new THREE.CircleGeometry(50, 50),
					new THREE.MeshBasicMaterial({
						map: texture,
						transparent: true
					})
				);*/

			  // panel for the CANVAS
				plane = new THREE.Mesh(
				new THREE.CircleGeometry(50, 50),
				//new THREE.PlaneGeometry( 200, 200, 8, 8 ), 
				new THREE.MeshBasicMaterial({
					color: 0x000000, 
					opacity: 0.25, 
					transparent: true, 
					wireframe: false
				}));

				//plane.rotation.x = 0; //Math.PI / 2;
				//plane.position.z = 0;
				//plane.overdraw = true;
				//plane.dynamic = true;
				//scene.add(plane);

				plane.lookAt( camera.position );
				plane.visible = false;
				scene.add( plane );

				// PROJECTOR
				projector = new THREE.Projector();
				group = new THREE.Object3D();//create an empty container

				// RENDERER
				
				
				if( (navigator.userAgent.match(/Chrome/i)) ) {
					renderer = new THREE.WebGLRenderer( {antialias:true} );
				}
				else{
					renderer = new THREE.CanvasRenderer( {antialias:true} );
				}


				renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
				container = document.createElement( 'div' );
				document.body.appendChild( container );
				container.appendChild( renderer.domElement );

				// EVENTS
				THREEx.WindowResize(renderer, camera);
				THREEx.FullScreen.bindKey({ charCode : 'm'.charCodeAt(0) });
				
				// CONTROLS
				controls = new THREE.TrackballControls( camera );

				//------------------------------------------------
				//
				// EARTH
				//
				//------------------------------------------------

				var earthTexture = new THREE.Texture();
				var loader = new THREE.ImageLoader();

				loader.addEventListener( 'load', function ( event ) {
					earthTexture.image = event.content;
					earthTexture.needsUpdate = true;
				} );

				//loader.load( 'http://jsrun.it/assets/a/x/G/T/axGTG.jpg' );
				loader.load( 'axGTG2a.jpg' ); // get texture

				sphereSize = 250;

				var geometry = new THREE.SphereGeometry( sphereSize, 30, 20 );
				var material = new THREE.MeshBasicMaterial( { map: earthTexture, overdraw: true, opacity: 0.9 } );

				var geometry = new THREE.SphereGeometry( sphereSize, 30, 20 );
				// var material = new THREE.MeshBasicMaterial( { /*map: earthTexture,*/ overdraw: true, wireframe: false, color: 0xff0000, opacity: 0.4 } );

				cube =  new THREE.Mesh( geometry, material );
				cube.name = "sphere";

				//group.add( mesh );
				//scene.add( cube );
				//objects.push( cube );

				group.add( cube );//add a mesh with geometry to it
				scene.add(cube);
				//scene.add( group );//when done, add the group to the scene

				//////////////////////////////////////////////////////////////////////////////////

				Object.size = function(obj) {
					var size = 0, key;
					for (key in obj) {
						if (obj.hasOwnProperty(key)) size++;
					}
					return size;
				};

				// Get the size of an object
				//var size = Object.size(myArray);
				//console.log(Object.size(arGeo))
				
				for( var k=0; k < Object.size(arGeo); k++ ){ 

					//console.log(arGeo[k]['lat'] +'....'+ arGeo[k]['lon'] +'....'+ arGeo[k]['city'])

					var geometry = new THREE.SphereGeometry( 8, 2, 2 );
					var material = new THREE.MeshBasicMaterial( {  overdraw: true, wireframe: false, color: 0xff0000, opacity: 0.9 } );

					gpspoint =  new THREE.Mesh( geometry, material );

					posGeo = latLongToVector3( arGeo[k]['lat'], arGeo[k]['lon'], sphereSize+9, 1); // 51.52322;  -0.15778 // london 

					gpspoint.position.x = posGeo.x;
					gpspoint.position.y = posGeo.y;
					gpspoint.position.z = posGeo.z;
					gpspoint.name = ""+arGeo[k]['city'];
					gpspoint.desc = ""+arGeo[k]['wikipedia'];

					//scene.add( cubex );

					objects.push( gpspoint );
					group.add( gpspoint );//add a mesh with geometry to it
					scene.add( gpspoint );//when done, add the group to the scene
					scene.add( group );//when done, add the group to the scene
				}

				// create a canvas element
				canvas1 = document.createElement('canvas');
				context1 = canvas1.getContext('2d');
				context1.font = "Bold 14px Arial";
				context1.fillStyle = "rgba(0,0,0,0.95)";
				context1.fillText('Hello, world!', 0, 20);
				
				// canvas contents will be used for a texture
				texture1 = new THREE.Texture(canvas1);
				/*texture1 = THREE.ImageUtils.loadTexture(canvas1, {}, function() {
					renderer.render(scene);
				})*/
				texture1.needsUpdate = true;
		
				////////////////////////////////////////
				
				sprite1 = new THREE.Sprite( { map: texture1, useScreenCoordinates: true, alignment: THREE.SpriteAlignment.topLeft } );
				sprite1.position.set( 0, 0, 0 );
				scene.add( sprite1 );

				//////////////////////////////////////////
			
				/*var shape = new THREE.TextGeometry("Game Over");
				var wrapper = new THREE.MeshBasicMaterial({color: 0x00ff00});
				var words = new THREE.Mesh(shape, wrapper);
				scene.add(words);*/


				/*var theText = "Hello three.js! :)";
                 var hash = document.location.hash.substr(1);
                  if (hash.length === 0) {
                    
                  } else {
                   theText = hash;
                  }
                
                var text3d = new THREE.Text(theText, 8, 2, 4, "");
             
                //try MeshPhongMaterial MeshLambertMaterial MeshPhongMaterial MeshNormalMaterial
                var textMaterial = new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff, wireframe:false });
                text = new THREE.Mesh( text3d, textMaterial);
                
                text.doubleSided = false;
                text.position.y = 0;
                text.position.y = 0;
                text.position.z = 0;
                text.rotation.x = 0*Math.PI;
                text.rotation.y = Math.PI*2;
				text.overdraw = false;
                scene.add( text );*/




				//////////////////////////////////////////

				var PI2 = Math.PI * 2;
				particleMaterial = new THREE.ParticleCanvasMaterial( {

					color: 0x000000,
					program: function ( context ) {

						context.beginPath();
						context.arc( 0, 0, 1, 0, PI2, true );
						context.closePath();
						context.fill();

					}

				} );

				//------------------------------------------------
				//
				// STATS
				//
				//------------------------------------------------

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'mousedown', onDocumentMouseDown, false );
				document.addEventListener( 'touchstart', onDocumentTouchStart, false );
				document.addEventListener( 'touchmove', onDocumentTouchMove, false );

		
	


			}



			//------------------------------------------------
			//
			// latLongToVector3
			//
			//------------------------------------------------

			function latLongToVector3(lat, lon, radius, heigth) {

				var phi = (lat)*Math.PI/180;
				var theta = (lon-180)*Math.PI/180;

				var x = -(radius+heigth) * Math.cos(phi) * Math.cos(theta);
				var y = (radius+heigth) * Math.sin(phi);
				var z = (radius+heigth) * Math.cos(phi) * Math.sin(theta);

				return new THREE.Vector3(x,y,z);
			}


			//------------------------------------------------
			//
			// update
			//
			//------------------------------------------------

			function update()
			{
				
				// create a Ray with origin at the mouse position
				// and direction into the scene (camera direction)
				var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );
				projector.unprojectVector( vector, camera );
				
				var ray = new THREE.Ray( camera.position, vector.subSelf( camera.position ).normalize() );
				// create an array containing all objects in the scene with which the ray intersects
				var intersects = ray.intersectObjects( scene.children );
				// INTERSECTED = the object in the scene currently closest to the camera
				// and intersected by the Ray projected from the mouse position
				// if there is one (or more) intersections
				
				if ( intersects.length > 0 )
				{
					// if the closest object intersected is not the currently stored intersection object
					if ( intersects[ 0 ].object != INTERSECTED )
					{
						// restore previous intersection object (if it exists) to its original color
						if ( INTERSECTED )
							INTERSECTED.material.color.setHex( INTERSECTED.currentHex );
						// store reference to closest object as current intersection object
						INTERSECTED = intersects[ 0 ].object;
						// store color of closest object (for later restoration)
						INTERSECTED.currentHex = INTERSECTED.material.color.getHex();
						// set a new color for closest object
						INTERSECTED.material.color.setHex( 0xffff00 );

							/*var renderer2D = new THREE.CanvasRenderer();
							renderer2D.domElement.getContext('2d').fillText("Hello", 150, 150);
							renderer2D.domElement.textAlign = "center";
							renderer2D.domElement.textBaseline = "middle";

								var texture = new THREE.Texture(canvas1);
								texture.needsUpdate = true;*/
				
						// update text, if it has a "name" field.
						if ( intersects[ 0 ].object.name )
						{
							//console.log("INTERSECTED")

						}
						else
						{
							/*context1.clearRect(0,0,300,300);
							texture1.needsUpdate = true;*/
						}
					}
				}
				else // there are no intersections
				{
					// restore previous intersection object (if it exists) to its original color
					if ( INTERSECTED )
						INTERSECTED.material.color.setHex( INTERSECTED.currentHex );
						// remove previous intersection object reference
						// by setting current intersection object to "nothing"
					INTERSECTED = null;
					/*context1.clearRect(0,0,300,300);
					texture1.needsUpdate = true;*/
				}

				controls.update();
				stats.update();
			}

			//------------------------------------------------
			//
			// animate
			//
			//------------------------------------------------

			function animate() 
			{
				//requestAnimationFrame( animate );
				render();
				update();
			}

			function render() 
			{
				renderer.render( scene, camera );
			}


			//------------------------------------------------
			//
			// onDocumentMouseUp
			//
			//------------------------------------------------

			function onDocumentMouseUp( event ) {

				document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
				document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
				document.removeEventListener( 'mouseout', onDocumentMouseOut, false );
			}

			//------------------------------------------------
			//
			// onDocumentMouseOut
			//
			//------------------------------------------------

			function onDocumentMouseOut( event ) {
				document.removeEventListener( 'mousemove', onDocumentMouseMove, false );
				document.removeEventListener( 'mouseup', onDocumentMouseUp, false );
				document.removeEventListener( 'mouseout', onDocumentMouseOut, false );
			}

			//------------------------------------------------
			//
			// onDocumentTouchStart
			//
			//------------------------------------------------

			function onDocumentTouchStart( event ) {

				/*if ( event.touches.length == 1 ) {
					event.preventDefault();
					mouseXOnMouseDown = event.touches[ 0 ].pageX - windowHalfX;
					targetRotationOnMouseDown = targetRotation;

				}*/
			}

			//------------------------------------------------
			//
			// onDocumentTouchMove
			//
			//------------------------------------------------

			function onDocumentTouchMove( event ) {

				/*if ( event.touches.length == 1 ) {
					event.preventDefault();
					mouseX = event.touches[ 0 ].pageX - windowHalfX;
					targetRotation = targetRotationOnMouseDown + ( mouseX - mouseXOnMouseDown ) * 0.05;
				}*/

			}

			//------------------------------------------------
			//
			// loop
			//
			//------------------------------------------------

			function loop() {

				group.rotation.y += ( targetRotation - group.rotation.y ) * 0.05;
				group.rotation.x = (mouseY/windowHalfY) * Math.PI;

				//animate();
				renderer.render(scene, camera);
				update();
				stats.update();

				requestAnimationFrame( animate );
				

			}

			//------------------------------------------------
			//
			// onDocumentMouseMove
			//
			//------------------------------------------------

			function onDocumentMouseMove( event ) {

				event.preventDefault();
		
				sprite1.position.set( event.clientX+100, event.clientY+100, 0 );
					// update the mouse variable
				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;


				//
				var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 );
				projector.unprojectVector( vector, camera );
				var ray = new THREE.Ray( camera.position, vector.subSelf( camera.position ).normalize() );

				if ( SELECTED ) {
					/*var intersects = ray.intersectObject( plane );
					SELECTED.position.copy( intersects[ 0 ].point.subSelf( offset ) );
					return;*/
				}

				var intersects = ray.intersectObjects( objects );

				if ( intersects.length > 0 ) {

					if ( INTERSECTED != intersects[ 0 ].object ) {

						if ( INTERSECTED ) INTERSECTED.material.color.setHex( INTERSECTED.currentHex );

						INTERSECTED = intersects[ 0 ].object;
						INTERSECTED.currentHex = INTERSECTED.material.color.getHex();

						/*plane.position.copy( INTERSECTED.position );
						plane.lookAt( camera.position );*/

						container.style.cursor = 'pointer';
						//console.log("I was clicked"+INTERSECTED.name)

						context1.clearRect(0,0,340,280);
						var message = intersects[0].object.name 
						var metrics = context1.measureText(message);
						var width = metrics.width;

						//context1.fillStyle = "rgba(120,120,120,0.95)"; // black border
						//context1.fillRect( 0,0, width+12,20+4);
						context1.fillStyle = "rgba(255,255,255,0.95)"; // white filler
						context1.fillRect( 2,2, width+8,16+2 );
						context1.fillStyle = "rgba(0,0,0,1)"; // text color
						context1.fillText( message, 5,16 );
						texture1.needsUpdate = true;


					}

		

				

				} else {

				if ( INTERSECTED ) INTERSECTED.material.color.setHex( INTERSECTED.currentHex );
					INTERSECTED = null;
					container.style.cursor = 'auto';
					context1.clearRect(0,0,300,300);
					texture1.needsUpdate = true;

				}

			}

			//------------------------------------------------
			//
			// onDocumentMouseDown
			//
			//------------------------------------------------

			function onDocumentMouseDown( event ) {

				event.preventDefault();

				var vector = new THREE.Vector3( mouse.x, mouse.y, 0.5 );
				projector.unprojectVector( vector, camera );
				var ray = new THREE.Ray( camera.position, vector.subSelf( camera.position ).normalize() );

				var intersects = ray.intersectObjects( objects );
				
				if ( intersects.length > 0 ) {
					/*controls.enabled = false;
					SELECTED = intersects[ 0 ].object;
					var intersects = ray.intersectObject( plane );
					offset.copy( intersects[ 0 ].point ).subSelf( plane.position );
					container.style.cursor = 'move';*/
				}

			}

			//------------------------------------------------
			//
			// onDocumentMouseUp
			//
			//------------------------------------------------

			function onDocumentMouseUp( event ) {

				event.preventDefault();
				controls.enabled = true;
				if ( INTERSECTED ) {
					plane.position.copy( INTERSECTED.position );
					SELECTED = null;
				}
				container.style.cursor = 'auto';
			}

		//
			</script>

				<canvas width="1166" height="836" ></canvas>
					
			</body></html>